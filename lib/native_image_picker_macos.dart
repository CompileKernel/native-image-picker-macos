/// A macOS platform implementation of [image_picker](https://pub.dev/packages/image_picker)
/// using the native system picker instead of the system open file dialog.
///
/// This package is an alternative to [image_picker_macos](https://pub.dev/packages/image_picker_macos)
/// which uses [file_selector](https://pub.dev/packages/file_selector).
library;

import 'package:flutter/foundation.dart';
import 'package:image_picker_platform_interface/image_picker_platform_interface.dart';
import './src/messages.g.dart';
import 'src/image_picker_api_mapper.dart';
import 'src/image_picker_result_ext.dart';

/// A macOS implementation of [ImagePickerPlatform] and an alternative to the
/// [image_picker_macos](https://pub.dev/packages/image_picker_macos)
/// package.
///
/// It uses [PHPickerViewController](https://developer.apple.com/documentation/photosui/phpickerviewcontroller)
/// from [Apple PhotosUI](https://developer.apple.com/documentation/photosui)
/// instead of [NSOpenPanel](https://developer.apple.com/documentation/appkit/nsopenpanel).
///
/// It depends on the photos in the [Photos for macOS App](https://www.apple.com/in/macos/photos/)
/// and does **not require any runtime permissions** to access photos.
///
/// If the app has no photos or the user hasn't imported any, they will see `No Photos`
/// or `No Photos or Videos` messages, even if photos exist elsewhere (e.g., on the desktop).
/// The macOS Photos app supports importing images from an iOS device.
///
/// The `PHPickerViewController` is **available only on macOS 13.0+**, use [supportsPHPicker]
/// to check.
class NativeImagePickerMacOS extends CameraDelegatingImagePickerPlatform {
  /// Registers this class as the default instance of [ImagePickerPlatform].
  ///
  /// See also: [registerWithIfSupported]
  static void registerWith() {
    ImagePickerPlatform.instance = NativeImagePickerMacOS();
  }

  /// Registers [NativeImagePickerMacOS] on macOS
  /// if [PHPicker](https://developer.apple.com/documentation/photosui/phpickerviewcontroller)
  /// is supported in the current system version.
  ///
  /// PHPicker is **supported on macOS 13.0 and later**.
  ///
  /// Returns whether the instance has been registered.
  ///
  /// See also: [isRegistered]
  static Future<bool> registerWithIfSupported() async {
    if (await isSupported()) {
      registerWith();
      return true;
    }
    return false;
  }

  /// Returns whether the current [ImagePickerPlatform] instance is [NativeImagePickerMacOS].
  static bool isRegistered() =>
      ImagePickerPlatform.instance is NativeImagePickerMacOS;

  /// Returns whether the this implementation is supported on the current
  /// target platform.
  ///
  /// This implementation is supported on macOS 13 Ventura and higher.
  static Future<bool> isSupported() async {
    if (defaultTargetPlatform == TargetPlatform.macOS && !kIsWeb) {
      if (await _hostApi.supportsPHPicker()) {
        return true;
      }
    }
    return false;
  }

  /// Returns the current instance of [ImagePickerPlatform] as [NativeImagePickerMacOS]
  /// or `null` if it's not [NativeImagePickerMacOS].
  static NativeImagePickerMacOS? get instanceOrNull {
    final ImagePickerPlatform imagePickerImplementation =
        ImagePickerPlatform.instance;
    if (imagePickerImplementation is NativeImagePickerMacOS) {
      return imagePickerImplementation;
    }
    return null;
  }

  /// Returns the current instance of [ImagePickerPlatform] as [NativeImagePickerMacOS]
  /// or throws [StateError] if it's not [NativeImagePickerMacOS].
  static NativeImagePickerMacOS get instanceOrThrow =>
      instanceOrNull ??
      (throw StateError(
        'Expected the instance of $ImagePickerPlatform to be $NativeImagePickerMacOS'
        ' but got ${ImagePickerPlatform.instance.runtimeType}',
      ));

  /// The platform API generated by [Pigeon](https://pub.dev/packages/pigeon) for
  /// communicating with native macOS using a method channel.
  static final ImagePickerApi _hostApi = ImagePickerApi();

  /// Returns whether the current macOS version supports Apple PhotosUI Picker.
  ///
  /// The [PHPickerViewController](https://developer.apple.com/documentation/photosui/phpickerviewcontroller)
  /// from [Apple PhotosUI](https://developer.apple.com/documentation/photosui)
  /// is **supported on macOS 13.0+**
  Future<bool> supportsPHPicker() => _hostApi.supportsPHPicker();

  // Pick an image.
  @override
  Future<XFile?> getImageFromSource({
    required ImageSource source,
    ImagePickerOptions options = const ImagePickerOptions(),
  }) async {
    switch (source) {
      case ImageSource.camera:
        return super.getImageFromSource(source: source);
      case ImageSource.gallery:
        final String? imagePath = (await _hostApi.pickImages(
          ImagePickerApiMapper.imageOptionsToImageSelectionOptions(options),
          GeneralOptions(limit: 1),
        ))
            .getSuccessOrThrow()
            .filePaths
            .firstOrNull;
        if (imagePath == null) {
          return null;
        }

        return XFile(imagePath);
    }
    // Ensure that there's a fallback in case a new source is added.
    // coverage:ignore-start
    // ignore: dead_code
    throw UnimplementedError(
      'Unknown ImageSource: $source. Consider updating the package or'
      ' filing an issue: https://pub.dev/packages/native-image-picker-macos',
    );
    // coverage:ignore-end
  }

  // Pick images.
  @override
  Future<List<XFile>> getMultiImageWithOptions({
    MultiImagePickerOptions options = const MultiImagePickerOptions(),
  }) async {
    final List<String> images = (await _hostApi.pickImages(
      ImagePickerApiMapper.imageOptionsToImageSelectionOptions(
        options.imageOptions,
      ),
      GeneralOptions(
        limit: options.limit ?? 0,
      ),
    ))
        .getSuccessOrThrow()
        .filePaths;
    return images.map((String imagePath) => XFile(imagePath)).toList();
  }

  // Pick a video.
  @override
  Future<XFile?> getVideo({
    required ImageSource source,
    CameraDevice preferredCameraDevice = CameraDevice.rear,
    Duration? maxDuration,
  }) async {
    switch (source) {
      case ImageSource.camera:
        return super.getVideo(
          source: source,
          preferredCameraDevice: preferredCameraDevice,
          maxDuration: maxDuration,
        );
      case ImageSource.gallery:
        final String? videoPath =
            (await _hostApi.pickVideos(GeneralOptions(limit: 1)))
                .getSuccessOrThrow()
                .filePaths
                .firstOrNull;
        if (videoPath == null) {
          return null;
        }

        return XFile(videoPath);
    }
    // Ensure that there's a fallback in case a new source is added.
    // coverage:ignore-start
    // ignore: dead_code
    throw UnimplementedError(
      'Unknown ImageSource: $source. Consider updating the package or'
      ' filing an issue: https://pub.dev/packages/native-image-picker-macos',
    );
    // coverage:ignore-end
  }

  // Pick media, including images and videos.
  @override
  Future<List<XFile>> getMedia({required MediaOptions options}) async {
    final List<String> images = (await _hostApi.pickMedia(
      MediaSelectionOptions(
        imageSelectionOptions:
            ImagePickerApiMapper.imageOptionsToImageSelectionOptions(
          options.imageOptions,
        ),
      ),
      GeneralOptions(
        limit: options.limit ?? (options.allowMultiple ? 0 : 1),
      ),
    ))
        .getSuccessOrThrow()
        .filePaths;
    return images.map((String mediaPath) => XFile(mediaPath)).toList();
  }

  /// Opens the [Photos for macOS](https://www.apple.com/in/macos/photos/) app.
  ///
  /// Returns whether the Photos app was successfully opened.
  ///
  /// Failure may occur if the Photos app is not installed, does not support
  /// the `photos://` URL scheme, or if a system-level issue prevents
  /// the app from launching.
  Future<bool> openPhotosApp() => _hostApi.openPhotosApp();

  // START: Backward compatibility

  // This is soft-deprecated in the platform interface, and is only implemented
  // for compatibility. Callers should be using getImageFromSource.
  @override
  Future<XFile?> getImage({
    required ImageSource source,
    double? maxWidth,
    double? maxHeight,
    int? imageQuality,
    CameraDevice preferredCameraDevice = CameraDevice.rear,
  }) =>
      getImageFromSource(
        source: source,
        options: ImagePickerOptions(
          maxWidth: maxWidth,
          maxHeight: maxHeight,
          imageQuality: imageQuality,
          preferredCameraDevice: preferredCameraDevice,
        ),
      );

  // This is soft-deprecated in the platform interface, and is only implemented
  // for compatibility. Callers should be using getImageFromSource.
  @override
  Future<PickedFile?> pickImage({
    required ImageSource source,
    double? maxWidth,
    double? maxHeight,
    int? imageQuality,
    CameraDevice preferredCameraDevice = CameraDevice.rear,
  }) async {
    final XFile? file = await getImage(
      source: source,
      maxWidth: maxWidth,
      maxHeight: maxHeight,
      imageQuality: imageQuality,
      preferredCameraDevice: preferredCameraDevice,
    );
    if (file != null) {
      return PickedFile(file.path);
    }
    return null;
  }

  // This is soft-deprecated in the platform interface, and is only implemented
  // for compatibility. Callers should be using getMultiImageWithOptions.
  // @override
  @override
  Future<List<XFile>> getMultiImage({
    double? maxWidth,
    double? maxHeight,
    int? imageQuality,
  }) async =>
      getMultiImageWithOptions(
        options: MultiImagePickerOptions(
          imageOptions: ImageOptions(
            imageQuality: imageQuality,
            maxHeight: maxHeight,
            maxWidth: maxWidth,
          ),
        ),
      );

  // This is soft-deprecated in the platform interface, and is only implemented
  // for compatibility. Callers should be using getVideo.
  @override
  Future<PickedFile?> pickVideo({
    required ImageSource source,
    CameraDevice preferredCameraDevice = CameraDevice.rear,
    Duration? maxDuration,
  }) async {
    final XFile? file = await getVideo(
      source: source,
      preferredCameraDevice: preferredCameraDevice,
      maxDuration: maxDuration,
    );
    if (file != null) {
      return PickedFile(file.path);
    }
    return null;
  }

  // END: Backward compatibility
}
